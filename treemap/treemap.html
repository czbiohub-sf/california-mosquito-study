<!DOCTYPE html>
<meta charset="utf-8">
<style>
body {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: auto;
  position: relative;
  width: 2400px;
}
.node {
  border: solid 1px white;
  /* opacity: 0.7; */
  font: 12px sans-serif;
  font-weight: 100;
  /* -webkit-text-stroke: 0.4px black; */
  line-height: 12px;
  overflow: hidden;
  position: absolute;
  text-indent: 2px;
  /* -webkit-text-stroke: 1px black; */
}

</style>

<div>
  <input type="radio" name="area" id="reads" value="read_count">
  <label for="reads">
    Number of reads
  </label>
</div>
<div>
  <input type="radio" name="area" id="contigs" value="contig_count" checked>
  <label for="contigs">
    Number of contigs
  </label>
</div>

<script src="//d3js.org/d3.v4.min.js"></script>
<script>
'use strict';

const margin = {top: 0, right: 0, bottom: 0, left: 0},
      width = 2400 - margin.left - margin.right,
      height = 1100 - margin.top - margin.bottom,
      color = d3.scaleOrdinal().range(d3.schemeCategory20c);

const treemap = d3.treemap()
    .size([width, height])
    .paddingTop(20) // padding
    .paddingLeft(3)
    .paddingRight(3)
    .paddingBottom(3);

treemap.tile(d3.treemapSquarify.ratio(1.3)) // aspect ratio of boxes

var tooltip = d3.select("body")
  .append("span")
	.style("position", "absolute")
  .style("background","lightgrey")
	.style("z-index", "10")
	.style("visibility", "hidden")
  .style("word-break","break-word")
  .style("white-space","pre-wrap")
	.text("");

const div = d3.select("body").append("div") // add div elements
    .style("position", "relative")
    .style("width", (width + margin.left + margin.right) + "px")
    .style("height", (height + margin.top + margin.bottom) + "px")
    .style("left", margin.left + "px")
    .style("top", margin.top + "px");

    var fname = "skeeters.json"
    d3.json(fname, function(error, data) {
      if (error) throw error;
      console.log(data)

      var score = function(d) {
        return d.attrs!=undefined ? d.attrs.contig_count : 0.01;
      }

      const root = d3.hierarchy(data, (d) => d.children);
      root.sum(function(d) {
        // console.log(d.taxonomy,score(d),d.attrs.colour)
        return score(d);
      });

      const tree = treemap(root);

      var filteredList = tree.descendants().filter(function(d) {
        return d;
      });
      console.log(filteredList)
      var colour = function(d) {
        return "slategrey";
      };

      var taxid = function(d) {
        // console.log(d)
        return d.data.taxid;
      };

      const node = d3.select("body").selectAll("div")
          .data(filteredList)
        .enter().append("div")
        .on("mouseover", function(d) { // selects json entry, allows access to tree and descendants
                tooltip.style("visibility", "visible");
                tooltip.text(d.data.taxonomy+
                              " \nRead count: "+
                              d.data.attrs.read_count+
                              " \nContig count: "+
                              d.data.attrs.contig_count)
                const taxids = d.descendants().map( x => x.data.taxid ); // get taxids of descendants
                d3.selectAll("div.node").filter(
                  x => taxids.includes(x.data.taxid)) // keep divs that are descendants of node
                .transition()
                  .duration(200)
                  .style("border-color","black")
                  .style("background","white")
                  .style("z-order",9999)
                })
          .on("mouseout", function(d) {
                tooltip.style("visibility", "hidden");
                const taxids = d.descendants().map( x => x.data.taxid);
                d3.selectAll("div.node").filter( x => taxids.includes(x.data.taxid))
              .transition()
                .duration(500)
                .style("border-color","white")
                .style("background", (d) => d.data.attrs.colour)
                // .style("background","slategrey")
                .style("z-order",0)
                })
          .on("mousemove", function(){
            return tooltip.style("top", (event.pageY-2)+"px")
                          .style("left",(event.pageX+2)+"px");
                          })
          .attr("class", "node")
          .attr("contig_count", (d) => d.data.attrs.contig_count)
          .attr("read_count", (d) => d.data.attrs.read_count)
          .attr("taxid", (d) => d.data.taxid)
          .style("left", (d) => d.x0 + "px")
          .style("top", (d) => d.y0 + "px")
          .style("width", (d) => Math.max(0, d.x1 - d.x0 - 1) + "px")
          .style("height", (d) => Math.max(0, d.y1 - d.y0  - 1) + "px")
          // .style("background", (d) => "slategrey")
          .style("background", (d) => d.data.attrs.colour)
          .style("opacity",0.7)
          .text((d) => d.data.taxonomy)
          // .attr("value", ((d) => score(d)))
          ;

      d3.selectAll("input").on("change", function change() {
        const value = this.value;
        const newRoot = d3.hierarchy(data, (d) => d.children)
          .sum(function(d) {
            return d.attrs != undefined ? d.attrs[value] : 0.0;
          });
        console.log(newRoot)
      //
        const newTree=treemap(newRoot)
        node.data(newTree.descendants())
          .transition()
            .duration(1500)
            .style("left", (d) => d.x0 + "px")
            .style("top", (d) => d.y0 + "px")
            .style("width", (d) => Math.max(0, d.x1 - d.x0 - 1) + "px")
            .style("height", (d) => Math.max(0, d.y1 - d.y0  - 1) + "px")
      });
    });
    // }
</script>
